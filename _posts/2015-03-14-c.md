---
layout: post
title: "C++赋值运算符重载，为什么要返回引用?"
description: ""
category: 
tags: []
---
{% include JB/setup %}

一、c/c++赋值运算符的本意为“返回左值的引用”(左值：赋值号左面的变量而非其值)

　　例：

　　int a, b = 3, c = 2;

　　(a = b) = c;

　　cout<<a<<b<<c<<endl;

    结果：232

　　对于a = b(a，b均为对象时)，若不返回左值的引用，将会生成临时对象。如果不处理a = b = c这样的表达式，也会正常(只是会调用拷贝构造函数和析构函数处理临时对象)。

　　二、为了进行连续赋值，即 x = y = z

　　1、赋值返回引用

　　x = y = z 先执行y = z，返回y的引用，执行x = y

　　2、赋值不返回引用

　　x = y = z 先执行y = z，返回用y初始化的临时对象(注意临时对象都是常对象)，再执行x = y的临时对象(要求operator=(const X&) )，返回用x初始化的临时对象(此处要求拷贝构造函数必须为X(const X&) )。

　　所以也并非必须返回引用，返回引用的好处既可以于赋值的原始语义已知，又可避免拷贝构造函数和析构函数的调用。

　　“题外话”：如果在类中没有说明本身的拷贝构造函数和赋值运算符，编译程序将会提供，但他们都只是对对象进行成员浅拷贝。在那些指向堆空间指针作为数据成员的类中，必须避免使用浅拷贝，而要为类定义自己的赋值运算符，以给对象分配堆内存。

　　PS：浅拷贝：调用系统默认的拷贝构造函数，不再新分配资源内存。深拷贝：调用自己的拷贝构造函数，分配新的资源内存。

　　拷贝构造函数用已存在的对象创建一个相同的新对象。而赋值运算符用已存在的对象赋予一个已存在的同类对象。

[原文地址](http://blog.sina.com.cn/s/blog_7acf47290100zv6j.html)  
今天发现的一个[tech blog](http://yanjunyi.com/blog/)主讲前端  
[makefile的使用](http://cyukang.com/2010/08/21/using-automake.html)  
